module Cells.Types where

import Data.Show (show)
import Prelude (class Eq, class Show, ($), (/=), (<<<), (<>))

import Data.Maybe (fromMaybe)
import Data.Generic (class Generic)
import Signal.Channel (Channel)
import Data.Array (dropWhile, filter, length, tail, takeWhile)
import Data.Lens (Lens', lens, over, view, (.~))
import Data.Argonaut (class DecodeJson, class EncodeJson, gDecodeJson, gEncodeJson)

defaultCellText :: String
defaultCellText = "Type here"

data Action
    = AddCodeCell
    | AddTextCell
    | SaveContent    CellId String
    | RemoveCell     CellId
    | RenderTextCell CellId
    | RenderCodeCell CellId
    | NoOp

data State = State
    { _currentCell :: CellId
    , _cells       :: Array Cell
    , _editorChanges :: Channel Action
    }

-- | Inserts a cell after a given Cell Id.
--   Cells could not be ordered:
--   > insertAfter 2 (newTextCell 4) s == s'
--   `s` is a State with the cells ordered as [2, 0, 1]
--   `s'` would be the same but with the order [2, 4, 0, 1]
insertAfter :: CellId -> Cell -> State -> State
insertAfter cId c s = (cells .~ firstHalf <> [c] <> secondHalf) s
  where
    firstHalf = takeWhile cellIdIsNotTheWanted $ view cells s
    secondHalf = fromMaybe [] <<< tail <<< dropWhile cellIdIsNotTheWanted $ view cells s
    cellIdIsNotTheWanted incomingCell = view cellId incomingCell /= cId

removeCell :: CellId -> State -> State
removeCell cId = over cells removeCellFromArray
  where
    removeCellFromArray = filter (\cell -> view cellId cell /= cId)

totalCells :: State -> Int
totalCells s = length $ view cells s

newtype CellId = CellId Int

derive instance genericCellId :: Generic CellId
derive instance eqCellId :: Eq CellId
instance showCellId :: Show CellId where
    show (CellId i) = show i

data Cell = Cell
    { _cellType    :: CellType
    , _cellId      :: CellId
    , _cellContent :: String
    }

derive instance genericCell :: Generic Cell

instance encodeJsonCell :: EncodeJson Cell where
    encodeJson = gEncodeJson

instance decodeJsonCell :: DecodeJson Cell where
    decodeJson = gDecodeJson

newCell :: CellType -> String -> CellId -> Cell
newCell cType cContent id' = Cell
    { _cellId      : id'
    , _cellContent : cContent
    , _cellType    : cType
    }

newTextCell :: CellId -> Cell
newTextCell = newCell TextCell defaultCellText

newCodeCell :: CellId -> Cell
newCodeCell = newCell CodeCell ("-- " <> defaultCellText)

data CellType
    = TextCell
    | CodeCell

derive instance genericCellType :: Generic CellType

instance encodeJsonCellType :: EncodeJson CellType where
    encodeJson = gEncodeJson

instance decodeJsonCellType :: DecodeJson CellType where
    decodeJson = gDecodeJson

-- Autogenerated lens for currentCell 
currentCell  :: Lens' State CellId
currentCell  = lens
    (\(State o) -> o._currentCell )
    (\(State o) -> (\newValue -> State (o { _currentCell  = newValue } ) ) )

-- Autogenerated lens for cells 
cells  :: Lens' State  (Array Cell)
cells  = lens
    (\(State  o) -> o._cells )
    (\(State  o) -> (\newValue -> State  (o { _cells  = newValue } ) ) )

-- Autogenerated lens for editorChanges 
editorChanges  :: Lens' State  (Channel Action)
editorChanges  = lens
    (\(State  o) -> o._editorChanges )
    (\(State  o) -> (\newValue -> State  (o { _editorChanges  = newValue } ) ) )

-- Autogenerated lens for cellId 
cellId  :: Lens' Cell CellId
cellId  = lens
    (\(Cell o) -> o._cellId )
    (\(Cell o) -> (\newValue -> Cell (o { _cellId  = newValue } ) ) )

-- Autogenerated lens for cellType 
cellType  :: Lens' Cell  CellType
cellType  = lens
    (\(Cell  o) -> o._cellType )
    (\(Cell  o) -> (\newValue -> Cell  (o { _cellType  = newValue } ) ) )

-- Autogenerated lens for cellContent 
cellContent  :: Lens' Cell String
cellContent  = lens
    (\(Cell o) -> o._cellContent )
    (\(Cell o) -> (\newValue -> Cell (o { _cellContent  = newValue } ) ) )
